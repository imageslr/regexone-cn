(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{387:function(t,e,o){"use strict";o.r(e);var s=o(48),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"课程-14-条件"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#课程-14-条件"}},[t._v("#")]),t._v(" 课程 14：条件")]),t._v(" "),o("p",[t._v("正如我们前面提到的，更准确总是好的，这适用于编码、对话、以及正则表达式。例如，您不会写一份购物清单让别人"),o("strong",[t._v("买更多的 .*")]),t._v(" (Buy more .*)，因为您不知道您能得到什么。相反，您可以写"),o("strong",[t._v("买更多的牛奶")]),t._v(" (Buy more milk) 或"),o("strong",[t._v("买更多的面包")]),t._v(" (Buy more bread)。在正则表达式中，我们可以明确地定义这些条件 (conditionals)。")]),t._v(" "),o("p",[t._v("我们可以使用 "),o("strong",[o("code",[t._v("|")]),t._v(" (逻辑或 locigal OR，也就是管道 pipe)")]),t._v(" 来表示"),o("strong",[t._v("可能的不同的字符集")]),t._v("，尤其是在使用组的时候。在上面的示例中，我们可以编写模式 "),o("code",[t._v("Buy more (milk|bread|juice)")]),t._v(" 来匹配字符串 Buy more milk、Buy more bread 或 Buy more juice。")]),t._v(" "),o("p",[t._v("与正常的组一样，您可以在条件 (condition) 中使用任何字符或元字符序列，例如，"),o("code",[t._v("([cb]ats*|[dh]ogs?)")]),t._v(" 将要么匹配 cats 或 bats，要么匹配 dogs 或 hogs。编写具有许多条件的模式可能很难阅读，因此如果它们太复杂，您应该考虑将它们拆分为单独的模式。")]),t._v(" "),o("p",[t._v("继续尝试写一个条件模式 (conditional pattern)，只匹配下面包含小动物的行。")]),t._v(" "),o("Exercise",{attrs:{title:"练习 14：匹配条件文本",data:[{type:"match",text:"I love cats"},{type:"match",text:"I love dogs"},{type:"skip",text:"I love logs"},{type:"skip",text:"I love cogs"}]}},[t._v("通过使用逻辑或，我们可以使用表达式 "),o("SolutionLink",{attrs:{text:"I love (cats|dogs)"}}),t._v(" 来匹配前两行。")],1)],1)}),[],!1,null,null,null);e.default=r.exports}}]);